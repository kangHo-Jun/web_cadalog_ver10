# 📚 Vercel 배포 학습 노트

> **작성일**: 2026-01-26  
> **프로젝트**: Cafe24 Web Catalog  
> **주제**: Vercel 서버리스 배포와 상태 관리

---

## 🎯 오늘 겪은 핵심 문제

**증상**: 로컬에서는 정상 작동하던 Cafe24 API 연동이 Vercel 배포 후 `invalid_grant` 에러 발생

**근본 원인**: Vercel 서버리스 환경의 **Stateless(무상태)** 특성을 이해하지 못함

---

## 1️⃣ Vercel 배포의 핵심 구조

### Vercel이란?

**Vercel = 서버리스 플랫폼 + CDN + 자동 배포**

```
GitHub Repository
       ↓ (Push)
Vercel Build System
       ↓ (자동 빌드)
Serverless Functions (AWS Lambda 기반)
       ↓
CDN (전 세계 엣지 네트워크)
       ↓
사용자
```

### 핵심 특징

| 특징 | 설명 | 영향 |
|------|------|------|
| **Serverless** | 요청마다 새로운 함수 인스턴스 생성 | 메모리/파일 시스템 초기화 |
| **Stateless** | 요청 간 상태 공유 불가 | 파일 저장 불가능 |
| **Read-only FS** | `/` 디렉토리 읽기 전용 | `/tmp`만 쓰기 가능 (임시) |
| **Cold Start** | 첫 요청 시 함수 초기화 시간 소요 | 성능 고려 필요 |

### 로컬 vs Vercel 차이

```
┌─────────────────────────────────────────────────────────┐
│ 로컬 개발 환경 (Traditional Server)                      │
├─────────────────────────────────────────────────────────┤
│ ✅ 서버 프로세스가 계속 실행됨                            │
│ ✅ 파일 시스템에 데이터 저장 가능                         │
│ ✅ 메모리에 변수 유지 가능                                │
│ ✅ 한 번 로드한 토큰을 계속 사용                          │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ Vercel 프로덕션 (Serverless)                             │
├─────────────────────────────────────────────────────────┤
│ ❌ 요청마다 새 함수 인스턴스 생성                         │
│ ❌ 파일 저장해도 다음 요청에서 사라짐                     │
│ ❌ 메모리 변수도 요청 종료 시 소멸                        │
│ ❌ 토큰을 저장할 영구 저장소 필요                         │
└─────────────────────────────────────────────────────────┘
```

---

## 2️⃣ 시행착오의 원인 분석

### 문제 1: 파일 기반 토큰 저장 시도

**초기 코드** (`cafe24-auth.ts`):
```typescript
// ❌ 로컬에서는 작동, Vercel에서는 실패
const TOKEN_PATH = path.join(process.cwd(), '.tokens.json');
fs.writeFileSync(TOKEN_PATH, JSON.stringify(tokens));
```

**왜 실패했나?**
1. Vercel은 `/` 디렉토리가 **읽기 전용**
2. `/tmp`에 저장해도 **인스턴스 재시작 시 삭제**
3. 여러 서버리스 인스턴스가 **파일을 공유하지 못함**

```
요청 1 → 인스턴스 A → /tmp/.tokens.json 저장
요청 2 → 인스턴스 B → /tmp/.tokens.json 없음! ❌
```

### 문제 2: 환경 변수만으로 해결 시도

**시도한 방법**:
```bash
# Vercel 환경 변수에 토큰 저장
CAFE24_ACCESS_TOKEN=xxx
CAFE24_REFRESH_TOKEN=yyy
```

**왜 부족했나?**
- Cafe24 Access Token은 **2시간마다 만료**
- Refresh Token으로 갱신하면 **새 Refresh Token 발급**
- 환경 변수는 **재배포 없이 업데이트 불가능**

```
2시간 후 → Access Token 만료
  ↓
Refresh Token으로 갱신
  ↓
새 Refresh Token 발급됨
  ↓
환경 변수는 여전히 옛날 값 ❌
  ↓
다음 갱신 시 invalid_grant 에러!
```

---

## 3️⃣ Redis(Vercel KV)가 왜 필요했는지?

### Redis의 역할

**Redis = 초고속 Key-Value 저장소**

```
┌─────────────────────────────────────────────────────────┐
│ Vercel KV (Upstash Redis)                                │
├─────────────────────────────────────────────────────────┤
│ ✅ 모든 서버리스 인스턴스가 공유                          │
│ ✅ 데이터 영구 저장 (재시작해도 유지)                     │
│ ✅ 읽기/쓰기 속도 매우 빠름 (ms 단위)                     │
│ ✅ 글로벌 복제 (전 세계 어디서든 빠름)                    │
└─────────────────────────────────────────────────────────┘
```

### 토큰 갱신 플로우 (Redis 사용)

```
사용자 요청
  ↓
Serverless Function A 실행
  ↓
Redis에서 토큰 조회
  ↓
Access Token 만료 확인
  ↓
Refresh Token으로 새 토큰 발급
  ↓
새 토큰을 Redis에 저장 ✅
  ↓
다음 요청 (다른 인스턴스)
  ↓
Serverless Function B 실행
  ↓
Redis에서 최신 토큰 조회 ✅ (공유됨!)
```

### 대안 비교

| 저장소 | 속도 | 영구성 | 공유 | 비용 | 적합성 |
|--------|------|--------|------|------|--------|
| **파일 시스템** | 빠름 | ❌ | ❌ | 무료 | ❌ |
| **환경 변수** | 빠름 | ✅ | ✅ | 무료 | ⚠️ (정적 데이터만) |
| **Redis (KV)** | 매우 빠름 | ✅ | ✅ | 무료 티어 | ✅ **최적** |
| **PostgreSQL** | 보통 | ✅ | ✅ | 무료 티어 | 🆗 (과한 선택) |

---

## 4️⃣ GitHub에서 직접 배포할 수는 없었는지?

### GitHub Pages vs Vercel

| 기능 | GitHub Pages | Vercel |
|------|--------------|--------|
| **정적 사이트** | ✅ | ✅ |
| **서버리스 함수** | ❌ | ✅ |
| **환경 변수** | ❌ | ✅ |
| **자동 빌드** | ✅ (Jekyll) | ✅ (Next.js 등) |
| **API 라우트** | ❌ | ✅ |

**결론**: 우리 프로젝트는 **Cafe24 API를 호출하는 서버리스 함수**가 필요하므로 GitHub Pages로는 불가능

### GitHub Actions + 다른 호스팅?

**가능한 조합**:
```
GitHub → GitHub Actions (빌드) → AWS Lambda (배포)
GitHub → GitHub Actions (빌드) → Google Cloud Run (배포)
GitHub → GitHub Actions (빌드) → Netlify (배포)
```

**Vercel을 선택한 이유**:
- Next.js와 **완벽한 통합** (Vercel이 Next.js 개발사)
- **자동 배포** (GitHub 푸시만 하면 끝)
- **무료 티어** 충분
- **KV 저장소** 내장

---

## 5️⃣ Vercel의 역할 (데이터를 저장?)

### Vercel의 3가지 역할

```
┌─────────────────────────────────────────────────────────┐
│ 1. 빌드 & 배포 자동화                                     │
├─────────────────────────────────────────────────────────┤
│ GitHub Push → 자동 빌드 → 배포 → URL 생성                │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 2. 서버리스 함수 실행 환경                                │
├─────────────────────────────────────────────────────────┤
│ /api/products → AWS Lambda 함수 실행                     │
│ /api/categories → AWS Lambda 함수 실행                   │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 3. 정적 파일 CDN 호스팅                                   │
├─────────────────────────────────────────────────────────┤
│ HTML, CSS, JS → 전 세계 엣지 서버에 캐싱                 │
└─────────────────────────────────────────────────────────┘
```

### Vercel은 데이터를 저장하는가?

**❌ 기본적으로는 저장하지 않음**

- Vercel은 **코드 실행 환경**일 뿐
- 데이터 저장은 **별도 서비스 필요**:
  - **Vercel KV** (Redis) - 우리가 사용
  - **Vercel Postgres** (관계형 DB)
  - **Vercel Blob** (파일 저장)
  - 외부 DB (Supabase, PlanetScale 등)

---

## 6️⃣ GitHub와 Vercel 연결

### 연결 방식

```
┌──────────────┐         ┌──────────────┐
│   GitHub     │ ◄─────► │   Vercel     │
│  Repository  │  Webhook │   Project    │
└──────────────┘         └──────────────┘
       │                        │
       │ Push                   │ Deploy
       ▼                        ▼
   main 브랜치            Production URL
```

### 자동 배포 플로우

```
1. 개발자가 코드 수정
   ↓
2. git push origin main
   ↓
3. GitHub → Vercel Webhook 전송
   ↓
4. Vercel이 자동으로:
   - 코드 클론
   - npm install
   - npm run build
   - 서버리스 함수 배포
   - CDN에 정적 파일 업로드
   ↓
5. 새 URL 생성 (또는 기존 URL 업데이트)
   ↓
6. 배포 완료 알림
```

### 환경 변수 관리

```
로컬 개발:
  .env.local (Git에 커밋 안 함)
    ↓
Vercel 프로덕션:
  Vercel Dashboard > Settings > Environment Variables
    ↓
  빌드 시 자동 주입
```

---

## 7️⃣ 로컬 vs Vercel 시행착오 정리

### 타임라인

| 시간 | 상황 | 문제 | 해결 |
|------|------|------|------|
| **로컬 개발** | ✅ 정상 작동 | - | - |
| **Vercel 첫 배포** | ❌ "검색 결과 없음" | 에러 메시지 숨겨짐 | `ProductTable.tsx` fetcher 수정 |
| **에러 확인** | ❌ `invalid_grant` | 토큰 만료 | 새 토큰 발급 |
| **토큰 업데이트** | ❌ 2시간 후 재발생 | 파일 저장 실패 | `/tmp` 시도 |
| **`/tmp` 사용** | ⚠️ 간헐적 실패 | 인스턴스 간 공유 안 됨 | Vercel KV 도입 |
| **Vercel KV** | ✅ 완벽 해결 | - | - |

### 핵심 교훈

```
로컬 환경 = 전통적인 서버 (Stateful)
  ↓
Vercel = 서버리스 (Stateless)
  ↓
상태 저장이 필요하면 → 외부 저장소 필수!
```

---

## 🎓 배운 핵심 개념

### 1. Serverless의 본질

**"서버가 없다"가 아니라 "서버를 신경 쓰지 않는다"**

- 요청마다 함수가 실행되고 종료됨
- 상태를 유지하려면 **외부 저장소** 필수
- 파일 시스템은 **임시 저장소**로만 사용

### 2. Stateless Architecture

```
전통적인 서버:
  메모리에 변수 저장 → 계속 유지 ✅

서버리스:
  메모리에 변수 저장 → 요청 끝나면 소멸 ❌
  
해결책:
  Redis, DB 등 외부 저장소 사용 ✅
```

### 3. OAuth 토큰 관리

**토큰 특성**:
- Access Token: 짧은 수명 (2시간)
- Refresh Token: 긴 수명 (2주), 하지만 갱신 시 변경됨

**서버리스 환경에서의 해결책**:
```
1. 환경 변수에 초기 토큰 저장
2. Redis에 현재 토큰 저장
3. 만료 시 자동 갱신
4. 새 토큰을 Redis에 업데이트
5. 모든 인스턴스가 Redis에서 최신 토큰 조회
```

### 4. 배포 환경 차이 이해

| 항목 | 로컬 | Vercel |
|------|------|--------|
| **파일 시스템** | 읽기/쓰기 자유 | 읽기 전용 (+ /tmp 임시) |
| **프로세스** | 계속 실행 | 요청마다 생성/종료 |
| **환경 변수** | `.env.local` | Vercel Dashboard |
| **디버깅** | 콘솔 직접 확인 | Vercel Logs 확인 |

---

## 💡 실전 팁

### 1. 서버리스 개발 시 체크리스트

- [ ] 상태 저장이 필요한가? → Redis/DB 고려
- [ ] 파일 업로드가 있는가? → Blob Storage 필요
- [ ] 환경 변수 설정했는가? → Vercel Dashboard 확인
- [ ] 로컬과 프로덕션 동작이 다른가? → 서버리스 특성 재확인

### 2. 디버깅 전략

```
1. 로컬에서 먼저 완벽히 작동시키기
2. 에러 핸들링 강화 (try-catch, 로그)
3. Vercel 배포 후 Logs 확인
4. 환경 변수 누락 여부 체크
5. 서버리스 제약사항 재확인
```

### 3. 비용 최적화

**Vercel 무료 티어 한도**:
- Serverless Functions: 100GB-시간/월
- KV: 30,000 요청/월
- Bandwidth: 100GB/월

**초과 방지 팁**:
- 불필요한 API 호출 줄이기
- 캐싱 적극 활용
- 이미지 최적화

---

## 📚 참고 자료

- [Vercel Serverless Functions 공식 문서](https://vercel.com/docs/functions)
- [Vercel KV 가이드](https://vercel.com/docs/storage/vercel-kv)
- [Next.js 배포 최적화](https://nextjs.org/docs/deployment)
- [OAuth 2.0 토큰 관리 Best Practices](https://oauth.net/2/)

---

## 🎯 다음 학습 목표

1. **Edge Functions** 이해하기
2. **Middleware** 활용법
3. **ISR (Incremental Static Regeneration)** 적용
4. **Vercel Analytics** 설정
5. **성능 모니터링** 도구 활용
