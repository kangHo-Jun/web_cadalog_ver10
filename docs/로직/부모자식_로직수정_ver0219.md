# 로직 수정 명세서 (2026-02-19)

대산 스마트 카탈로그의 부모-자식 상품 연결 및 출력 방식에 대한 개선안을 정리합니다.

---

## 0. 핵심 수정 사항 (디버깅 결과 반영)

### `has_option` 참조 경로 수정
- **잘못된 경로**: `product.has_option` (최상위 → `undefined`)
- **올바른 경로**: `product.options?.has_option` (options 객체 내부에 존재)
- **원인**: Cafe24 API에서 `embed=options`로 조회 시, `has_option`이 최상위가 아닌 `options` 객체 안에 포함됨

### 카테고리 번호 수정
- **잘못된 값**: `[325, 326, 327, 328, 329, 330, 331, 332, 333]` (하드코딩)
- **올바른 값**: `quote-categories.ts`의 `QUOTE_CATEGORY_NOS` 사용

| 카테고리 번호 | 명칭 |
| :---: | :--- |
| 192 | 합판/MDF/보드 |
| 25 | 각재/목재 |
| 50 | 석고/텍스 |
| 197 | 바닥재/특수목 |
| 203 | 집성목 |
| 284 | UV코팅/방염 |
| 254 | 몰딩도어/하드웨어 |
| 220 | 실내마감재 |
| 223 | 철물/부자재 |
| 26 | 단열재/흡음재 |

### `display` 필터 누락 수정
- **문제**: 카테고리별 상품 조회 시 `display` 파라미터 없이 전체 상품을 가져옴 → **진열 안 함** 상품까지 포함
- **수정**: API 호출 시 `display: 'T'` 추가 → **진열함** 상품만 조회
- **영향 파일**: `src/app/api/sync-products/route.ts`, `src/app/api/products/route.ts`

| 파일 | 수정 전 | 수정 후 |
| :--- | :--- | :--- |
| `sync-products/route.ts` | `{ category, embed, limit }` | `{ category, embed, limit, display: 'T' }` |
| `products/route.ts` (quote) | `{ product_name, category, selling, limit }` | `{ product_name, category, selling, display: 'T', limit }` |
| `products/route.ts` (normal) | `{ product_name, category, selling, limit }` | `{ product_name, category, selling, display: 'T', limit }` |

### 검증 결과 (2026-02-19 테스트)
- 전체 부모 상품 수: **244개**
- 옵션 상품 (`has_option: 'T'`): **18개** (자식 2개 이상)
- 단일 상품 (`has_option: 'F'`): **226개** (자식 1개 = 부모 자체)

---

## 1. 부모 상품 출력 로직 (Parent Output)

### 변경 사항
- **기존**: 상품명에서 `(`나 `x` 문자를 발견하면 그 이전까지만 잘라서 출력 (정규화 단계에서 강제 절삭)
- **수정**: 상품명 **전체**를 출력하되, 오직 HTML 태그 및 특수 공백만 제거

### 상세 정제 로직 (`normalizeProductName` in `src/lib/product-utils.ts`)
1. `<br>`, `<p>` 등 모든 HTML 태그를 제거 (공백으로 치환)
2. `&nbsp;`, `&amp;`, `&lt;`, `&gt;` 등 HTML 엔티티 제거
3. 상품명 중간의 `(`나 `x`를 기준으로 **자르지 않음** (전체 명칭 유지)
4. 연속된 공백을 하나로 축소 및 앞뒤 공백 제거

---

## 2. 자식 상품 출력 로직 (Child Output)

상품의 옵션 보유 여부에 따라 두 가지 방식으로 처리합니다.

### Case A: 옵션 상품 (`options.has_option: 'T'`)
- **부모 식별**: `product_code` (8자리, 예: `P0000CAT`)
- **자식 식별**: `variant_code` (부모코드 + 접미사, 예: `P0000CAT000A`)
- **자식 명칭**: `options.options[0].option_value`의 `value` 또는 `option_text`
- **자식 가격**: `product.price` + `variant.additional_amount`
- **구조**: 부모 상품 아래에 해당 옵션 리스트를 자식 상품으로 나열

### Case B: 단일 상품 (`options.has_option: 'F'`)
- **정의**: 부모이면서 동시에 옵션 1개짜리 상품
- **구조**: 부모 자체를 자식 1개로 반환 (`isSingle: true` 플래그)
- **가격**: `product.price` 그대로 사용

---

## 3. 로직 비교

### 옵션 상품 예시 (ID: 1543, P0000CHJ)

| 항목 | 기존 로직 (절삭형) | 수정된 로직 (전체형 + 옵션화) |
| :--- | :--- | :--- |
| **부모 명칭** | "프리미엄" | **"프리미엄 단열재 PF보드 LX지인"** |
| **자식 리스트** | 품목 코드(variants) 위주 | **실제 옵션값(`option_value`) 위주** |
| **자식 출력 예** | `P0000CHJ000A` | **`30T x 1000 x 1800`** |

### 옵션 상품 예시 (ID: 1371, P0000CAT)

| 항목 | 값 |
| :--- | :--- |
| **부모 명칭** | "일반합판 3x6 910x1820mm" |
| **자식 수** | 6개 |
| **자식 출력 예** | `2.7T x 910 x 1820 동남아산` |
| **option_value 키** | `option_text` (value가 아님 - 방어적 처리 필요) |

### 단일 상품 예시 (P0000CHV)

| 항목 | 값 |
| :--- | :--- |
| **부모 명칭** | "자이 천연 방수석고보드 12.5T x 900 x 1800mm (1236)" |
| **자식 수** | 1개 (부모 = 자식) |
| **isSingle** | `true` |

---

## 4. option_value 필드명 차이

API 응답에 따라 `option_value` 배열 내부 키가 다릅니다:

| 상품 | 필드 키 | 예시 값 |
| :--- | :--- | :--- |
| P0000CHJ (PF보드) | `value` | `"30T x 1000 x 1800"` |
| P0000CAT (일반합판) | `option_text` | `"2.7T x 910 x 1820 동남아산"` |

**방어적 처리**: `ov.value || ov.option_text || ''`

---

## 5. 최종 구현 코드

적용 파일: `src/app/api/sync-products/route.ts`, `src/app/api/cron/sync-products/route.ts`

```javascript
// 카테고리: quote-categories.ts에서 import
import { QUOTE_CATEGORY_NOS } from '@/config/quote-categories';
const CATEGORY_NOS = QUOTE_CATEGORY_NOS;

// API 호출 시 embed 필수, display: 'T'로 진열함 상품만 조회
const response = await apiClient.get('/products', {
  params: { category: catNo, embed: 'options,variants', display: 'T', limit: 100 }
});

// 1. 부모 명칭 처리 (normalizeProductName 사용)
const parentName = normalizeProductName(product.product_name);

// 2. 자식 리스트 처리
let children = [];

if (product.options?.has_option === 'T') {
  // Case A: 옵션 상품 → option_value 기반 자식 리스트
  const optionValues = product.options?.options?.[0]?.option_value || [];
  const variants = product.variants || [];

  children = optionValues.map(ov => {
    const name = ov.value || ov.option_text || '';
    const matchedVariant = variants.find(v =>
      v.options?.some(o => o.value === name)
    );
    const price = Number(product.price) + Number(matchedVariant?.additional_amount || 0);
    return { name, price, variantCode: matchedVariant?.variant_code || '' };
  }).filter(child => child.name);

} else {
  // Case B: 단일 상품 → 부모 자체를 1개 자식으로 반환
  children = [{
    name: parentName,
    price: Number(product.price || 0),
    isSingle: true
  }];
}
```

---

## 6. 수정 이력

| 일자 | 내용 |
| :--- | :--- |
| 2026-02-19 | 초안 작성 |
| 2026-02-19 | `has_option` 경로 수정 (`product.has_option` → `product.options?.has_option`) |
| 2026-02-19 | 카테고리 번호 수정 (325~333 → `QUOTE_CATEGORY_NOS` import) |
| 2026-02-19 | `option_text` 방어적 처리 확인 |
| 2026-02-19 | 단일상품 정의 확정: 부모 = 옵션 1개짜리 상품 (`isSingle: true`) |
| 2026-02-20 | `display: 'T'` 필터 추가 — 진열함 상품만 조회하도록 수정 (`sync-products`, `products` API) |
