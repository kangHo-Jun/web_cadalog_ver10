# 부모_자식분류_ver1

## 1. 목적

카테고리별 상품 데이터를 수집하여 부모 코드(앞 8자리) 기준으로
그룹화하고, 옵션(variant)을 자식 구조로 정리한 뒤 Redis에 스냅샷 형태로
저장한다.

이를 통해 프론트엔드에서 실시간 API 호출 없이 Redis snapshot 기반으로
빠르게 렌더링할 수 있도록 한다.

------------------------------------------------------------------------

## 2. 전체 구조 흐름

1.  CATEGORY_NOS 배열 기준으로 반복 API 호출
2.  각 카테고리에서 products + variants 데이터 수집
3.  product_code 앞 8자리 기준으로 부모 그룹화
4.  variants를 children 배열로 정리
5.  Redis에 snapshot 저장

------------------------------------------------------------------------

## 3. 그룹화 로직

### 3.1 부모 코드 기준

product_code가 8자리 이상일 경우:

parentCode = product_code.substring(0, 8)

예시:

12345678AA\
12345678BB

→ 부모 코드: 12345678

------------------------------------------------------------------------

### 3.2 결과 구조

{ "12345678": { "parentName": "...", "children": \[ { "variantCode":
"...", "variantName": "...", "price": "..." } \] } }

-   parentName: 첫 번째 매칭 상품의 product_name 사용
-   children: variants 정보만 포함

------------------------------------------------------------------------

## 4. Redis Snapshot 전략

SNAPSHOT_KEY: catalog:snapshot:v1

-   동기화 API는 전체 데이터를 가공 후 Redis에 저장
-   프론트는 Redis snapshot만 조회
-   버전 관리를 통해 구조 변경 대응 가능 (v1 → v2)

------------------------------------------------------------------------

## 5. Next.js 설정

export const dynamic = 'force-dynamic' export const revalidate = 0

-   Next.js 캐싱 비활성화
-   Redis를 단일 캐시 소스로 사용

------------------------------------------------------------------------

## 6. 설계 의도

기존 구조: 프론트 → API → 가공 → 렌더

변경 구조: 프론트 → Redis snapshot → 즉시 렌더

목표: - 응답 속도 향상 - 프론트 로직 단순화 - 운영 안정성 확보 - API
호출 부하 감소

------------------------------------------------------------------------

## 7. 주의 사항

1.  limit=100 초과 시 페이지네이션 필요
2.  Redis 연결 방식은 트래픽 증가 시 pooling 고려
3.  동일 parentCode 내 product_name이 다를 경우 정합성 검토 필요

------------------------------------------------------------------------

## 8. 결론

이 구조는 실시간 호출 기반 시스템에서 스냅샷 기반 캐시 아키텍처로
전환하는 1단계 설계이다.

향후: - snapshot 검증 로직 추가 - sync endpoint 보호 (token) - snapshot
read API 분리 - 증분 업데이트 전략 검토
